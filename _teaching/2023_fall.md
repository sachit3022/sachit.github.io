---
title: "Introduction to programming II - C++"
collection: teaching
type: "Undergraduate course TA"
permalink: /teaching/2023-fall
venue: "Michigan State University"
date: 2023-08-28
---
This course is taught by [Dr Josh Nahum](http://www.nahum.us/). Information related to the CSE 232 course can be found [here](https://www.cse.msu.edu/~cse232/). All the credit is directed towards [Dr Josh Nahum](http://www.nahum.us/). This page provides commentary and supplementary details of the Lab section of the course. This page also gives credit to amazing students who ask  <span style="color:green"> good questions that deserve mention </span> üç´.

|  Content     |  Description   |
| :---        |    :----:   | 
| [Labs](https://sachit3022.github.io/teaching/2023-fall) | Once place stop for all the lab content, see below | 
| [Problem Sets ](https://sachit3022.github.io/files/CSE_232_problem_sets.pdf)  | List down the problem sets for all the important topics with explanations  | 

# LAB 0
The goal of the lab is to introduce [pair programming](https://martinfowler.com/articles/on-pair-programming.html). The story of famous google [pair programmers](https://www.newyorker.com/magazine/2018/12/10/the-friendship-that-made-google-huge) Jeff Dean and Sanjay Ghemawat. These labs provides you safe space to think and give you hands on experience, which will help you with the exams and home works.
# LAB 1
I/O operations, Type casting of C++, How to think programatically.

üç´: <span style="color:green">When the The waves travel there will be the inertia to the wave and also and there will be increase in distance from the moment wave left the planet?</span>

Yes, from the perspective of physics, this point is completly valid. Generally, The time take for round trip wave travel is given by $\frac{2*\textit{distance}}{c}$, but if there is a relative velocity, i.e one planet is moving with respect to other, then we need to account for 2 things planet movement adds intertia so velocity of wave will be ( c + v ), as light can be treated as both particle and wave. and the return distance will not be d but ( d + vt ). 
$$
\textit{time} = \frac{2*\textit{distance}}{c}
$$
$$
\textit{time} = \frac{2*\textit{distance}}{c - 2v}
$$
As $v <<<< c$, and we only need time in 2 decimal precision, 2v can be ignored.

<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vR1fDeBXfSHbF3kliFZc5IhWyQWpLpFpqThbTY1HNpkyvbtikJKjelski9jHFb4U8xU7sc_LdyAv9F9/embed?start=true&loop=false&delayms=30000" frameborder="0" width="480" height="299" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

# LAB 2
Introduction to functions, loops, Intro to recursion and time complexity.

<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTz2gJyantbKlGkKQFVdtWjANmFwfrnl0MIC-B4OZPXEBXTV146AKwuk6-NTriHB_bajnmhGorZAvt-/embed?start=true&loop=false&delayms=5000" frameborder="0" width="480" height="299" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>

Problem given a integer you need to return the sum of digits recuresively.
Suppose 999 -> 27 -> 9

We will build from scratch, maximum integer is 9...(9) count. So we can always get the single number in maximum of 3 steps, we will try with dirty code and start cleaning and make it reusable and modular.

üç´: <span style="color:green">for loop implementation of counting digit</span>

General trick to count digits is implememented using while loop, but there is a for loop implementation
```cpp
for (n; n != 0; n = n/10){
    r = n % 10;
    sum = sum + r;
}
```
- [no recurresion](/files/lab_cpp/no_recursion.cpp)
- [functions](/files/lab_cpp/add_function.cpp)
- [no repeatable code](/files/lab_cpp/full_recurssion.cpp)

# LAB 3
The objective of the lab is to find the area of the polynomial function.
THe concepts that we use here is exponential search algorithm, To motivate you further, this is not some mathematical problem, we can this is applied to real life cases.
Suppose MSU wants to install routers in one of the halls, If you install one router, there will be lot of complaints, if 2 routers complaints decreases but if you do routers more than students it will be of no use wasting money, So MSU needs to decide optimal amount of routers given complaints < 5.
Same applies to the number of items on menu at the dining halls. you get the idea by now.

Major problems I see is you are struggling with the syntax and logic. We will focus one at a time. If you are comfortable in python write the code in python ( less worry about sytax) and then I will help you write cpp or you can figure out on your own.

Revise last lab, We have covered recrsion, loops and lab before that we covered input output, datatypes and precision. In this lab we will learn about functions.

Lets get back to our initial problem.
We will start with simple functions, 



The solution of the problem is given below. 
```cpp
#include <iostream>
#include <math.h>
#include <iomanip> 

// YOUR FUNCTIONS GO HERE
double Fn(double x){
  return -6*pow(x,2) +5*x +3;
}
double Integral(double x){
  return -2*pow(x,3) +5*pow(x,2)/2 +3*x;
}

double EstimateWithTraps(double a, double b, int n){
  double dx = (b - a)/n;
  double area_dx =0;
  double x =a;
  for(int i=0;i<n;i++){
    area_dx += dx*(std::abs(Fn(x)) + std::abs(Fn(x+dx)))/2;
    x +=dx;
  }
  return area_dx;
}

// Trapezoid calculation method...
int main()
{
  double a,b,tolerance,estimated_area,acutal_area,curr_tolerance;
  int n;
  std::cout <<"Lower Range:" <<std::endl;
  std::cin >> a;
  std::cout <<"Upper Range:" <<std::endl;
  std::cin >> b;
  std::cout <<"Tolerance:" <<std::endl;
  std::cin >> tolerance;
  std::cout <<"Initial trapezoid count:" <<std::endl;
  std::cin >> n;
  curr_tolerance = tolerance +1;
  while(curr_tolerance>tolerance){
    estimated_area = EstimateWithTraps(a,b,n);
    acutal_area = std::abs(Integral(b)) - std::abs(Integral(a));
    curr_tolerance = std::abs(estimated_area- acutal_area);
    std::cout << "Estimate:"<< std::fixed << std::setprecision(4) <<estimated_area << ", Number of Traps:"<<n<<", Diff:"<<curr_tolerance<<std::endl;
    n = n*2;
  }
  return 0;

}
```

# LAB 4

```cpp

#include <iostream>
#include <cmath>
#include <string>
using namespace std;

std::int64_t LocToDec(std::string const & loc){
  long int dec =0;
  for(std::string::size_type i = 0; i < loc.size(); ++i){
    dec += pow(2,loc[i] - 97);
  }
  return dec;
}

std::string DecToLoc(std::int64_t dec){
  std::string loc;
  int loop_count =0;
  while(dec !=0){
    int rem = dec % 2;
    dec = (dec - rem) / 2;
    if(rem>0){
      loc += (char)(loop_count+97);
    }
    loop_count +=1; 
  }
  return loc;
}
std::string Abbreviate(std::string const & loc)
{
  return DecToLoc(LocToDec(loc));

}
std::int64_t AddLoc(std::string const & loc1, std::string const & loc2)
{
  return LocToDec(loc1+loc2);
}

int main()
{

  string loc, string1,string2;
  long int dec;

  cout << "Give me a location string:";  
  cin >> loc;
  cout << "Give me an integer:";
  cin >> dec ;
  sort(loc.begin(), loc.end());
  cout << loc << " to dec: " << LocToDec(loc) << endl;
  cout << dec << " to loc: " << DecToLoc(dec) << endl;
  cout << "Give me two more location strings:";
  cin >> string1;
  cin >> string2;

}
```

